//============================================================================================
/**
 * @file	gf_standard.c
 * @brief	Ｃ標準関数 + 乱数関数
 * @author	GAME FREAK inc.
 * @date	2006.11.29
 */
//============================================================================================
#include "gflib.h"
#include "gf_standard.h"



//----------------------------------------------------------------------------
/**
 *	@brief	メモリ領域を比較する
 *	@param	s1	比較メモリー1
 *	@param	s2	比較メモリー2
 *	@param	size	比較サイズ
 *	@retval	０   同じ
 *	@retval	！０ 異なる
 */
//-----------------------------------------------------------------------------
int GFL_STD_MemComp(const void *s1, const void *s2, const u32 size)
{
    const unsigned char  *p1 = (const unsigned char *)s1;
    const unsigned char  *p2 = (const unsigned char *)s2;
    u32 n = size;

    while (n-- > 0) {
        if (*p1 != *p2)
            return (*p1 - *p2);
        p1++;
        p2++;
    }
    return (0);
}

/*-----------------------------------------------------------------------------
 *
 *	H16/11/10		Tomoya Takahashi
 *	
 *				MT方での乱数発生関数
 *
 ----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
 *					定数宣言
 ----------------------------------------------------------------------------*/
#define N 624						///< 乱数配列の要素数
#define M 397						///< 自然数
#define MATRIX_A 0x9908b0dfUL		///< 求めた値の１ビット目が１の時にXORする値 
#define UPPER_MASK 0x80000000UL		///< ビットのw-rビットを取得するマクロ	今はw = 32 r = 31です。
#define LOWER_MASK 0x7fffffffUL		///< ビットのrビットを取得するマクロ		こうすると３２ビット符号なしの乱数を取得できます。

/*-----------------------------------------------------------------------------
 *					グローバル変数
 ----------------------------------------------------------------------------*/
static u32 mt[N];						///< MTの式の結果の入る配列
static int mti=N+1;						///< 配列要素番号(N+1の時は初期化されていない)
static u32 mag01[2]={0x0UL, MATRIX_A};	///< 式の結果１ビット目を添え字番号として入れてXorをするテーブル

/**-----------------------------------------------------------------------------
 *
 *	@brief   メルセンヌツイスター初期化関数 RTCとvsyncnumで初期化してください
 *	@param   s  シード値(この値から初期化値が線形合同法で生成されます)
 *  @return  none
 * 
 ----------------------------------------------------------------------------*/
void GFL_STD_MtRandInit(u32 s)
{
//    mt[0]= s & 0xffffffff;			// シード値を要素０に代入
    mt[0]= s ;			// シード値を要素０に代入

	//
	// 線形合同法で乱数を生成
	//
    for (mti=1; mti<N; mti++) {
        mt[mti] = 
	    (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti); 
//        mt[mti] &= 0xffffffff;
    }
}

/**-----------------------------------------------------------------------------
 *  @brief   メルセンヌツイスターで符号なし３２ビット長の乱数を取得
 *	@return  生成された乱数
------------------------------------------------------------------------------*/
u32 __GFL_STD_MtRand(void)
{
    u32 y;
    
	//
	// 乱数の生成
	//
	// 式から乱数を生成するかのチェック
    if (mti >= N) {		// 無限にループさせる
		int kk;			// 式の計算ループ用

		// mtiがN+1のときは初期化
        if (mti == N+1)   
		{
			GFL_STD_MtRandInit(5489UL);		// 適当な値で初期化
		}

		//
		// mtiがNになったので
		// 式から乱数を生成（僕もわかりません）
		// 
        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;		// 先頭に戻す
    }
  
	//
	// 今の乱数を取得
	// 
    y = mt[mti++];

	// この下の処理でもっと値を分布させています。
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}




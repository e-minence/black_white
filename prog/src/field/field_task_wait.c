////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * @brief  フィールドタスク(空処理)
 * @file   field_task_wait.c
 * @author obata
 * @date   2009.11.18
 */
////////////////////////////////////////////////////////////////////////////////////////////////
#include <gflib.h>
#include "field_task.h"
#include "fieldmap.h"
#include "field_task_wait.h"


//==========================================================================================
// ■タスクワーク
//==========================================================================================
typedef struct
{
  u16 nowFrame;  // 経過時間
  u16 endFrame;  // 終了時間

} TASK_WORK;


//==========================================================================================
// ■非公開関数のプロトタイプ宣言
//==========================================================================================
static RETVAL_MAIN Wait( void* wk );


//----------------------------------------------------------------------------------------------
/**
 * @brief 指定フレーム数の寿命を持つ空処理タスクを作成する
 *
 * @param fieldmap 動作フィールドマップ
 * @param frame    動作フレーム数
 */
//----------------------------------------------------------------------------------------------
FIELD_TASK* FIELD_TASK_Wait( FIELDMAP_WORK* fieldmap,  u16 frame )
{
  FIELD_TASK* task;
  TASK_WORK* work;
  HEAPID heap_id = FIELDMAP_GetHeapID( fieldmap );

  // 生成
  task = FIELD_TASK_Create( heap_id, sizeof(TASK_WORK), Wait );
  // 初期化
  work = FIELD_TASK_GetWork( task );
  work->nowFrame = 0;
  work->endFrame = frame;

  return task;
}


//==========================================================================================
// ■タスク処理関数
//==========================================================================================

//------------------------------------------------------------------------------------------
/**
 * @brief カメラの等速ズーム
 */
//------------------------------------------------------------------------------------------ 
static RETVAL_MAIN Wait( void* wk )
{
  TASK_WORK* work = (TASK_WORK*)wk;

  // 更新
  work->nowFrame++;

  // 終了チェック
  if( work->endFrame <= work->nowFrame )
  {
    return FINISH;
  }
  return CONTINUE;
}

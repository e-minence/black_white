//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
/**
 *	GAME FREAK inc.
 *
 *	@file		weather.c
 *	@brief		天気システム
 *	@author		tomoya takahashi
 *	@data		2009.03.17
 *
 */
//]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]


#include <gflib.h>

#include "weather_task.h"

#include "weather.h"

//-----------------------------------------------------------------------------
/**
 *					コーディング規約
 *		●関数名
 *				１文字目は大文字それ以降は小文字にする
 *		●変数名
 *				・変数共通
 *						constには c_ を付ける
 *						staticには s_ を付ける
 *						ポインタには p_ を付ける
 *						全て合わさると csp_ となる
 *				・グローバル変数
 *						１文字目は大文字
 *				・関数内変数
 *						小文字と”＿”と数字を使用する 関数の引数もこれと同じ
*/
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/**
 *					定数宣言
*/
//-----------------------------------------------------------------------------

//-------------------------------------
///	天気変更タイプ
//=====================================
enum{
	FIELD_WEATHER_CHANGETYPE_NORMAL,		// 通常
	FIELD_WEATHER_CHANGETYPE_MULTI,			// マルチ（流しながら）

	FIELD_WEATHER_CHANGETYPE_NUM,			// システム内で使用
} ;

//-------------------------------------
///	シーケンス
//=====================================
// NORMAL
enum {
	FIELD_WEATHER_NORMAL_SEQ_NONE,
	
	FIELD_WEATHER_NORMAL_SEQ_NOW_FADEOUT,
	FIELD_WEATHER_NORMAL_SEQ_NOW_FADEOUTWAIT,
	FIELD_WEATHER_NORMAL_SEQ_NEXT_OVERLAY_LOAD,
	FIELD_WEATHER_NORMAL_SEQ_NEXT_FADEIN,
} ;

// MULTI
enum {
	FIELD_WEATHER_MULTI_SEQ_NONE,
	
	FIELD_WEATHER_MULTI_SEQ_FADE_INOUT,
	FIELD_WEATHER_MULTI_SEQ_FADE_OUTWAIT,
} ;



//-------------------------------------
///	天気ワーク　保持数
//=====================================
enum{
	FIELD_WEATHER_WORK_NOW,
	FIELD_WEATHER_WORK_NEXT,

	FIELD_WEATHER_WORK_NUM,
};


//-------------------------------------
///	セルユニットワーク数
//=====================================
#define FIELD_WEATHER_CLUNIT_WORK_MAX	( 96 )


//-----------------------------------------------------------------------------
/**
 *					構造体宣言
*/
//-----------------------------------------------------------------------------
//-------------------------------------
///	天気システムワーク
//=====================================
struct _FIELD_WEATHER{

	// 切り替えシーケンス
	u16		change_type;
	u16		seq;
	u16		now_weather;
	u16		next_weather;

	// 予約
	u16		booking_weather;

	// セルアクターユニット
	GFL_CLUNIT*	p_unit;

	// 天気動作システム
	WEATHER_TASK* p_task[ FIELD_WEATHER_WORK_NUM ];
	
	// 今のオーバレイID
	FSOverlayID	now_overlayID;
};



//-----------------------------------------------------------------------------
/**
 *					天気情報
 */
//-----------------------------------------------------------------------------
//-------------------------------------
///	天気情報型
//=====================================
typedef struct {
	const WEATHER_TASK_DATA*	cp_data;			// 天気情報
	FSOverlayID					overlay_id;			// オーバーレイID
} FIELD_WEATHER_DATA;
static const FIELD_WEATHER_DATA sc_FIELD_WEATHER_DATA[] = {
	{
		NULL,
		NO_OVERLAY_ID
	},
};


//-----------------------------------------------------------------------------
/**
 *					プロトタイプ宣言
*/
//-----------------------------------------------------------------------------
//-------------------------------------
///	システム管理
//=====================================
static void FIELD_WEATHER_OVERLAY_Load( FIELD_WEATHER* p_sys, FSOverlayID overlay );
static void FIELD_WEATHER_OVERLAY_UnLoad( FIELD_WEATHER* p_sys );

//-------------------------------------
///	天気切り替え処理
//=====================================
static void FIELD_WEATHER_CHANGE_Normal( FIELD_WEATHER* p_sys, u32 heapID );
static void FIELD_WEATHER_CHANGE_Multi( FIELD_WEATHER* p_sys, u32 heapID );




//----------------------------------------------------------------------------
/**
 *	@brief	フィールド天気システム	初期化
 *
 *	@param	cp_camera	フィールドカメラ
 *	@param	heapID		ヒープID
 *
 *	@return	システムワーク
 */
//-----------------------------------------------------------------------------
FIELD_WEATHER* FIELD_WEATHER_Init( const FIELD_CAMERA* cp_camera, u32 heapID )
{
	FIELD_WEATHER* p_sys;
	int i;

	p_sys = GFL_HEAP_AllocClearMemory( heapID, sizeof(FIELD_WEATHER) );

	// メンバ初期化
	p_sys->change_type		= FIELD_WEATHER_CHANGETYPE_NORMAL;
	p_sys->seq				= 0;
	p_sys->now_weather		= FIELD_WEATHER_NO_NONE;
	p_sys->next_weather		= FIELD_WEATHER_NO_NONE;
	p_sys->booking_weather	= FIELD_WEATHER_NO_NONE;
	p_sys->now_overlayID	= GFL_OVERLAY_BLANK_ID;

	// セルユニット初期化
	p_sys->p_unit = GFL_CLACT_UNIT_Create( FIELD_WEATHER_CLUNIT_WORK_MAX, FIELD_WEATHER_CLUNIT_PRI, heapID );
	

	for( i=0; i<FIELD_WEATHER_WORK_NUM; i++ ){
		p_sys->p_task[ i ] = WEATHER_TASK_Init( p_sys->p_unit, cp_camera, heapID );
	}

	return p_sys;
}

//----------------------------------------------------------------------------
/**
 *	@brief	フィールド天気破棄
 *
 *	@param	p_sys 
 */
//-----------------------------------------------------------------------------
void FIELD_WEATHER_Exit( FIELD_WEATHER* p_sys )
{
	int i;

	for( i=0; i<FIELD_WEATHER_WORK_NUM; i++ ){
		WEATHER_TASK_Exit( p_sys->p_task[i] );
	}

	// オーバーレイのアンロード
	FIELD_WEATHER_OVERLAY_UnLoad( p_sys );

	// セルユニット破棄
	GFL_CLACT_UNIT_Delete( p_sys->p_unit );

	GFL_HEAP_FreeMemory( p_sys );
}


//----------------------------------------------------------------------------
/**
 *	@brief	メイン処理
 *
 *	@param	p_sys	システムワーク
 */
//-----------------------------------------------------------------------------
void FIELD_WEATHER_Main( FIELD_WEATHER* p_sys, u32 heapID )
{
	int i;
	static void (*pFunc[FIELD_WEATHER_CHANGETYPE_NUM])( FIELD_WEATHER* p_sys, u32 heapID ) ={
		FIELD_WEATHER_CHANGE_Normal,
		FIELD_WEATHER_CHANGE_Multi,
	};

	// 切り替え処理
	GF_ASSERT( NELEMS( pFunc ) > p_sys->change_type );
	pFunc[ p_sys->change_type ]( p_sys, heapID );

	// 予約チェック
	if( p_sys->seq == 0 ){
		if( p_sys->booking_weather != FIELD_WEATHER_NO_NONE ){
			FIELD_WEATHER_Change( p_sys, p_sys->booking_weather );
			p_sys->booking_weather = FIELD_WEATHER_NO_NONE;
		}
	}

	// タスクメイン
	for( i=0; i<FIELD_WEATHER_WORK_NUM; i++ ){
		WEATHER_TASK_Main( p_sys->p_task[i], heapID );
	}
}

//----------------------------------------------------------------------------
/**
 *	@brief	天気フェードインなし設定
 *
 *	@param	p_sys			システムワーク
 *	@param	weather_no		天気ナンバー
 */
//-----------------------------------------------------------------------------
void FIELD_WEATHER_Set( FIELD_WEATHER* p_sys, u32 weather_no, u32 heapID )
{
	int i;
	
	// 天気ナンバーチェック
	GF_ASSERT( weather_no < WEATHER_NO_NUM );
	GF_ASSERT( NELEMS(sc_FIELD_WEATHER_DATA) > weather_no );

	// 変更する意味があるか？
	if( weather_no != p_sys->now_weather ){

		// 全情報を破棄
		for( i=0; i<FIELD_WEATHER_WORK_NUM; i++ ){
			WEATHER_TASK_ForceEnd( p_sys->p_task[i] );
		}

		// オーバーレイ破棄
		FIELD_WEATHER_OVERLAY_UnLoad( p_sys );
		
		// シーケンスを初期化
		p_sys->seq = 0;

		// オーバーレイ読み込み
		FIELD_WEATHER_OVERLAY_Load( p_sys, sc_FIELD_WEATHER_DATA[ weather_no ].overlay_id );

		// フェードなし初期化
		WEATHER_TASK_Start( p_sys->p_task[ FIELD_WEATHER_WORK_NOW ], 
				sc_FIELD_WEATHER_DATA[ weather_no ].cp_data, WEATHER_TASK_INIT_NORMAL, FALSE, TRUE, heapID );

		p_sys->now_weather	= weather_no;
		p_sys->next_weather	= FIELD_WEATHER_NO_NONE;
	}
}

//----------------------------------------------------------------------------
/**
 *	@brief	フェードインあり　天気変更
 *
 *	@param	p_sys			システムワーク
 *	@param	weather_no		天気ナンバー
 */
//-----------------------------------------------------------------------------
void FIELD_WEATHER_Change( FIELD_WEATHER* p_sys, u32 weather_no )
{

	// 天気ナンバーチェック
	GF_ASSERT( weather_no < WEATHER_NO_NUM );
	GF_ASSERT( NELEMS(sc_FIELD_WEATHER_DATA) > weather_no );

	// 実行中のリクエストがあるかチェック
	if( p_sys->seq != 0 ){
		p_sys->booking_weather = weather_no;
		return ;
	}

	// 天気が一緒なら何もしない
	if( p_sys->now_weather == weather_no ){
		return ;
	}

	// 次の天気を設定
	p_sys->next_weather = weather_no;
	
	// フェードアウト＋フェードイン
	p_sys->change_type	= FIELD_WEATHER_CHANGETYPE_NORMAL;
	p_sys->seq			= FIELD_WEATHER_NORMAL_SEQ_NOW_FADEOUT;
}

//----------------------------------------------------------------------------
/**
 *	@brief	天気ナンバーの取得
 *
 *	@param	cp_sys	システムワーク
 *	
 *	@return	今の天気ナンバーを取得
 */
//-----------------------------------------------------------------------------
u32 FIELD_WEATHER_GetWeatherNo( const FIELD_WEATHER* cp_sys )
{
	return cp_sys->now_weather;
}

//----------------------------------------------------------------------------
/**
 *	@brief	次の天気ナンバーの取得
 *
 *	@param	cp_sys	システムワーク
 *
 *	@return	次の天気ナンバー
 */
//-----------------------------------------------------------------------------
u32 FIELD_WEATHER_GetNextWeatherNo( const FIELD_WEATHER* cp_sys )
{
	return cp_sys->next_weather;
}






//-----------------------------------------------------------------------------
/**
 *			プライベート関数
 */
//-----------------------------------------------------------------------------
//----------------------------------------------------------------------------
/**
 *	@brief	オーバーレイ読み込み
 *
 *	@param	p_sys		システムワーク
 *	@param	overlay		オーバーレイ
 */
//-----------------------------------------------------------------------------
static void FIELD_WEATHER_OVERLAY_Load( FIELD_WEATHER* p_sys, FSOverlayID overlay )
{
	GF_ASSERT( p_sys->now_overlayID == GFL_OVERLAY_BLANK_ID );
	p_sys->now_overlayID = overlay;
	GFL_OVERLAY_Load( p_sys->now_overlayID );
}

//----------------------------------------------------------------------------
/**
 *	@brief	オーバーレイ破棄
 *
 *	@param	p_sys		システムワーク
 */
//-----------------------------------------------------------------------------
static void FIELD_WEATHER_OVERLAY_UnLoad( FIELD_WEATHER* p_sys )
{
	if( p_sys->now_overlayID != GFL_OVERLAY_BLANK_ID ){
		GFL_OVERLAY_Unload( p_sys->now_overlayID );
		p_sys->now_overlayID = GFL_OVERLAY_BLANK_ID;
	}
}



//----------------------------------------------------------------------------
/**
 *	@brief	天気変更　処理	通常
 *
 *	@param	p_sys		システムワーク
 *	@param	heapID		ヒープID
 */
//-----------------------------------------------------------------------------
static void FIELD_WEATHER_CHANGE_Normal( FIELD_WEATHER* p_sys, u32 heapID )
{
	switch( p_sys->seq ){
	case FIELD_WEATHER_NORMAL_SEQ_NONE:
		break;
	
		
	case FIELD_WEATHER_NORMAL_SEQ_NOW_FADEOUT:
		WEATHER_TASK_End( p_sys->p_task[ FIELD_WEATHER_WORK_NOW ], 
				TRUE, TRUE );
		p_sys->seq = FIELD_WEATHER_NORMAL_SEQ_NOW_FADEOUTWAIT;
		break;

	case FIELD_WEATHER_NORMAL_SEQ_NOW_FADEOUTWAIT:
		if( WEATHER_TASK_GetInfo( p_sys->p_task[ FIELD_WEATHER_WORK_NOW ] ) == WEATHER_TASK_INFO_NONE ){
			//  オーバーレイのアンロード
			FIELD_WEATHER_OVERLAY_UnLoad( p_sys );

			p_sys->seq = FIELD_WEATHER_NORMAL_SEQ_NEXT_OVERLAY_LOAD;
		}
		break;

	case FIELD_WEATHER_NORMAL_SEQ_NEXT_OVERLAY_LOAD:
		//  オーバーレイのアンロード
		FIELD_WEATHER_OVERLAY_Load( p_sys, sc_FIELD_WEATHER_DATA[ p_sys->next_weather ].overlay_id );
		p_sys->seq = FIELD_WEATHER_NORMAL_SEQ_NEXT_FADEIN;
		break;

	case FIELD_WEATHER_NORMAL_SEQ_NEXT_FADEIN:
		WEATHER_TASK_Start( p_sys->p_task[ FIELD_WEATHER_WORK_NOW ], 
				sc_FIELD_WEATHER_DATA[ p_sys->next_weather ].cp_data, 
				WEATHER_TASK_INIT_DIV, TRUE, TRUE, heapID );

		// 次への情報を消去
		p_sys->now_weather	= p_sys->next_weather;
		p_sys->next_weather	= FIELD_WEATHER_NO_NONE;

		p_sys->seq = FIELD_WEATHER_NORMAL_SEQ_NONE;
		break;

	default:
		GF_ASSERT(0);
		break;
	}
}

//----------------------------------------------------------------------------
/**
 *	@brief	天気マルチ変更処理
 *	
 *	@param	p_sys		システムワーク
 *	@param	heapID		ヒープID
 */
//-----------------------------------------------------------------------------
static void FIELD_WEATHER_CHANGE_Multi( FIELD_WEATHER* p_sys, u32 heapID )
{
	switch( p_sys->seq ){
	case FIELD_WEATHER_MULTI_SEQ_NONE:
		break;
	
		
	case FIELD_WEATHER_MULTI_SEQ_FADE_INOUT:
		WEATHER_TASK_Start( p_sys->p_task[ FIELD_WEATHER_WORK_NEXT ], 
				sc_FIELD_WEATHER_DATA[ p_sys->next_weather ].cp_data, 
				WEATHER_TASK_INIT_DIV, TRUE, FALSE, heapID );

		WEATHER_TASK_End( p_sys->p_task[ FIELD_WEATHER_WORK_NOW ], 
				TRUE, FALSE );

		p_sys->seq = FIELD_WEATHER_MULTI_SEQ_FADE_OUTWAIT;
		break;
	
	case FIELD_WEATHER_MULTI_SEQ_FADE_OUTWAIT:
		if( WEATHER_TASK_GetInfo( p_sys->p_task[ FIELD_WEATHER_WORK_NOW ] ) == WEATHER_TASK_INFO_NONE ){

			// 次を今に
			{
				WEATHER_TASK* p_tmp;

				p_tmp = p_sys->p_task[ FIELD_WEATHER_WORK_NOW ];
				p_sys->p_task[ FIELD_WEATHER_WORK_NOW ]		= p_sys->p_task[ FIELD_WEATHER_WORK_NEXT ];
				p_sys->p_task[ FIELD_WEATHER_WORK_NEXT ]	= p_tmp;
				p_sys->now_weather	= p_sys->next_weather;
				p_sys->next_weather = FIELD_WEATHER_NO_NONE;
			}
			
			p_sys->seq = FIELD_WEATHER_MULTI_SEQ_NONE;
		}
		break;
	
	default:
		GF_ASSERT(0);
		break;
	}
}


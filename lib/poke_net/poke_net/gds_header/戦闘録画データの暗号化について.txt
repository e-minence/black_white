戦闘録画は録画本体のみ暗号化をしています。
ヘッダーは暗号化していません。

暗号、復号処理については下記の通りに行っています。

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================

{
	BATTLE_REC_WORK *rec;

	//チェックサムをキーにして暗号化
	BattleRec_Coded(rec, sizeof(BATTLE_REC_WORK) - GT_GDS_CRC_SIZE, rec->crc.crc16ccitt_hash + ((rec->crc.crc16ccitt_hash ^ 0xffff) << 16));

	//復号
	BattleRec_Decoded(rec, sizeof(BATTLE_REC_WORK) - GT_GDS_CRC_SIZE, rec->crc.crc16ccitt_hash + ((rec->crc.crc16ccitt_hash ^ 0xffff) << 16));
}


//============================================================================================
/**
 *	暗号処理
 *
 * @param[in]	data	暗号化するデータのポインタ
 * @param[in]	size	暗号化するデータのサイズ
 * @param[in]	code	暗号化キーの初期値
 */
//============================================================================================
static	void	BattleRec_Coded(BATTLE_REC_WORK *data,u32 size,u32 code)
{
	int	i;
	u16	*data_p=(u16 *)data;

	//暗号は、乱数暗号キーでマスク
	for(i=0;i<size/2;i++){
		data_p[i]^=CodeRand(&code);
	}
}

//============================================================================================
/**
 *	復号処理
 *
 * @param[in]	data	復号するデータのポインタ
 * @param[in]	size	復号するデータのサイズ
 * @param[in]	code	暗号化キーの初期値
 */
//============================================================================================
static	void	BattleRec_Decoded(BATTLE_REC_WORK *data,u32 size,u32 code)
{
	BattleRec_Coded(data,size,code);
}

//============================================================================================
/**
 *	乱数暗号キー生成ルーチン
 *
 * @param[in,out]	code	暗号キー格納ワークのポインタ
 *
 * @return	暗号キー格納ワークの上位2バイトを暗号キーとして返す
 */
//============================================================================================
static	u16 CodeRand(u32 *code)
{
    code[0] = code[0] *1103515245L + 24691;
    return (u16)(code[0] / 65536L) ;
}

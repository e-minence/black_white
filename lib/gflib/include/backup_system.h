//=============================================================================
/**
 * @file	backup_system.h
 * @brief	バックアップシステム・セーブデータ用ヘッダ
 * @author	tamada	GAME FREAK Inc.
 * @date	2007.06.14
 *
 *
 * このヘッダはセーブデータの生成処理、バックアップ領域へのアクセスなどの
 * 直接セーブデータにかかわる部分にのみ必要。
 *
 * 通常はSAVEDATA型（savedata_def.hで定義）を経由して各データにアクセスできればよいため、
 * このヘッダをインクルードする箇所は限定される。
 */
//=============================================================================
#pragma	once

#include "savedata_def.h"
#include <heap.h>

#ifdef __cplusplus
extern "C" {
#endif

//============================================================================================
//
//			セーブデータ構築用定義
//
//============================================================================================
///---------------------------------------------------------------------------
//---------------------------------------------------------------------------
typedef u32 (*FUNC_GET_SIZE)(void);

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
typedef void (*FUNC_INIT_WORK)(void *);

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
typedef u32 GFL_SVDT_ID;

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータ内容データ用の構造体定義
 */
//---------------------------------------------------------------------------
typedef struct {
	GFL_SVDT_ID		gmdataID;		///<セーブデータ識別ID
	FUNC_GET_SIZE	get_size;		///<セーブデータサイズ取得関数
	FUNC_INIT_WORK	init_work;		///<セーブデータ初期化関数
}GFL_SAVEDATA_TABLE;

//---------------------------------------------------------------------------
///	セーブデータ定義構造体
//---------------------------------------------------------------------------
typedef struct {
	const GFL_SAVEDATA_TABLE * table;	///<セーブデータ定義テーブルのアドレス
	u32 table_max;						      ///<セーブデータ定義テーブルの要素数
	u32 savearea_top_address;		  	///<使用するバックアップ領域の先頭アドレス
	u32 savearea_mirror_address;		///<使用するミラーリング領域の先頭アドレス
	                                ///<ミラーリング無しの場合はsavearea_top_addressと[同じ値]を指定
	u32 savearea_size;					///<使用するバックアップ領域の大きさ
	u32 magic_number;					///<使用するマジックナンバー
}GFL_SVLD_PARAM;



//============================================================================================
//
//				バックアップ制御関数
//
//============================================================================================
//---------------------------------------------------------------------------
/**
 * @brief	バックアップシステム起動
 * @param	heap_save_id
 *
 */
//---------------------------------------------------------------------------
extern void GFL_BACKUP_Init(u32 heap_save_id);

//---------------------------------------------------------------------------
/**
 * @brief	バックアップシステム終了
 */
//---------------------------------------------------------------------------
extern void GFL_BACKUP_Exit(void);
//---------------------------------------------------------------------------
/**
 * @brief	バックアップフラッシュ存在チェック
 * @retval	TRUE	フラッシュが存在する
 * @retval	FALSE	フラッシュが存在しない
 */
//---------------------------------------------------------------------------
extern BOOL GFL_BACKUP_IsEnableFlash(void);

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータ：ロード処理
 * @param	sv
 * @param heap_temp_id    この関数内でのみテンポラリとして使用するヒープID
 * @return	LOAD_RESULT
 */
//---------------------------------------------------------------------------
extern LOAD_RESULT GFL_BACKUP_Load(GFL_SAVEDATA * sv, u32 heap_temp_id);

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータ：セーブ処理
 * @param	sv
 * @return	SAVE_RESULT
 */
//---------------------------------------------------------------------------
extern SAVE_RESULT GFL_BACKUP_Save(GFL_SAVEDATA * sv);

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータ：消去処理
 * @param	sv			        セーブデータ構造へのポインタ
 * @param heap_temp_id    この関数内でのみテンポラリとして使用するヒープID
 */
//---------------------------------------------------------------------------
extern BOOL GFL_BACKUP_Erase(GFL_SAVEDATA * sv, u32 heap_temp_id);

//==================================================================
/**
 * フラッシュを工場出荷状態の値でクリアする
 *
 * @param   heap_id		    テンポラリヒープ
 * @param   flash_size		フラッシュのサイズ(byte)
 */
//==================================================================
extern void GFL_BACKUP_FlashErase(HEAPID heap_id, u32 flash_size);

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータ：分割セーブ：初期化
 */
//---------------------------------------------------------------------------
extern void GFL_BACKUP_SAVEASYNC_Init(GFL_SAVEDATA * sv);

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータ：分割セーブ：メイン
 */
//---------------------------------------------------------------------------
extern SAVE_RESULT GFL_BACKUP_SAVEASYNC_Main(GFL_SAVEDATA * sv);

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータ：分割セーブ：キャンセル
 */
//---------------------------------------------------------------------------
extern void GFL_BACKUP_SAVEASYNC_Cancel(GFL_SAVEDATA * sv);

//==================================================================
/**
 * 分割セーブ時、カードがロックされているか調べる
 *
 * @param   none		
 *
 * @retval  BOOL		TRUE:カードがロックされている
 * @retval  BOOL		FALSE:ロックされていない
 */
//==================================================================
extern BOOL GFL_BACKUP_SAVEASYNC_CheckCardLock(void);

//============================================================================================
//
//				セーブデータアクセス用関数
//
//============================================================================================
//==================================================================
/**
 * セーブデータシステム作成(セーブワークの実体を渡されたヒープで確保)
 *
 * @param   sv_param		
 * @param   heap_save_id		セーブシステムとセーブワーク実体の両方で使用
 *
 * @retval  GFL_SAVEDATA *		
 */
//==================================================================
extern GFL_SAVEDATA * GFL_SAVEDATA_Create(const GFL_SVLD_PARAM * sv_param, u32 heap_save_id);

//==================================================================
/**
 * セーブデータシステム作成(セーブワークの実体は外側で渡してもらう　※外部セーブでの使用を想定
 *
 * @param   sv_param		
 * @param   heap_save_id		セーブシステムで使用
 * @param   svwk_adrs       セーブワーク実体として使用するワークのポインタ
 * @param   svwk_size       svwk_adrsのサイズ
 * @param   svwk_clear      svwk_adrsがNULLでない場合、
 *                            TRUE:バッファの初期化を行う
 *                            FALSE:バッファの初期化は行わない
 *
 * @retval  GFL_SAVEDATA *		
 */
//==================================================================
extern GFL_SAVEDATA * GFL_SAVEDATA_CreateEx(const GFL_SVLD_PARAM * sv_param, 
  u32 heap_save_id, void *svwk_adrs, u32 svwk_size, BOOL svwk_clear );

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータ解放処理
 * @param	sv		セーブデータへのポインタ
 */
//---------------------------------------------------------------------------
extern void GFL_SAVEDATA_Delete(GFL_SAVEDATA * sv);

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータ初期化
 * @param	sv		セーブデータへのポインタ
 *
 * バックアップへの書き込みは行わず、データの初期化処理のみを行う
 */
//---------------------------------------------------------------------------
extern void GFL_SAVEDATA_Clear(GFL_SAVEDATA * sv);

//---------------------------------------------------------------------------
/**
 * @brief	最初の読み込み時のセーブデータ状態取得
 * @param	sv		セーブデータへのポインタ
 * @return	LOAD_RESULT		ロード結果情報
 */
//---------------------------------------------------------------------------
extern LOAD_RESULT GFL_SAVEDATA_GetLoadResult(const GFL_SAVEDATA * sv);

//---------------------------------------------------------------------------
/**
 * @brief	データが存在するかどうかの判別フラグ取得
 * @param	sv		セーブデータへのポインタ
 * @retval	TRUE	存在する
 * @retval	FALSE	存在しない
 */
//---------------------------------------------------------------------------
extern BOOL GFL_SAVEDATA_GetExistFlag(const GFL_SAVEDATA * sv);

//==================================================================
/**
 * セーブデータワークの先頭アドレスを取得
 * @param   sv		セーブデータ構造へのポインタ
 * @param   size  実セーブデータサイズ
 * @retval  const void *		セーブデータワークの先頭アドレス
 */
//==================================================================
extern const void * GFL_SAVEDATA_GetSaveWorkAdrs(GFL_SAVEDATA * sv, u32 *size);

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータの各要素取得
 * @param	gmdataID	データＩＤ
 * @return	void * として各要素へのポインタを返す
 */
//---------------------------------------------------------------------------
extern void * GFL_SAVEDATA_Get(GFL_SAVEDATA * sv, GFL_SVDT_ID gmdataID);

//---------------------------------------------------------------------------
/**
 * @brief	セーブデータの各要素取得
 * @param	gmdataID	データＩＤ
 * @return	void * として各要素へのポインタを返す
 *
 * 読み込み専用として扱いたい場合にGFL_SAVEDATA_Getと切り分けて使用する
 */
//---------------------------------------------------------------------------
extern const void * GFL_SAVEDATA_GetReadOnly(const GFL_SAVEDATA * sv, GFL_SVDT_ID gmdataID);

//--------------------------------------------------------------
/**
 * セーブを実行した場合のセーブサイズを取得する
 *
 * @param   sv		        セーブデータ構造へのポインタ
 * @param   actual_size		セーブされる実サイズ(CRCテーブルなどのシステム系のデータは除きます)
 * @param   total_size		セーブ全体のサイズ(CRCテーブルなどのシステム系のデータは除きます)
 *
 * 差分比較の為、フラッシュアクセスします。
 */
//--------------------------------------------------------------
extern void GFL_SAVEDATA_GetActualSize(GFL_SAVEDATA *sv, u32 *actual_size, u32 *total_size);

//--------------------------------------------------------------
/**
 * @brief   ブロックのCRCを現在のデータで更新する
 *
 * @param   sv				セーブデータ構造へのポインタ
 * @param   gmdataid		セーブデータID
 *
 * @retval  生成されたCRC値
 */
//--------------------------------------------------------------
extern u16 GFL_BACKUP_BlockCRC_Set(GFL_SAVEDATA *sv, GFL_SVDT_ID gmdataid);

//==============================================================================
//	デバッグ用関数
//==============================================================================
#ifdef PM_DEBUG
extern void DEBUG_GFL_BACKUP_BlockSaveFlagGet(const GFL_SAVEDATA *sv, GFL_SVDT_ID gmdataid, BOOL crctable, BOOL footer, BOOL *ret_a, BOOL *ret_b);
extern void DEBUG_BACKUP_DataWrite(GFL_SAVEDATA *sv, GFL_SVDT_ID gmdataid, void *data, int write_offset, int size, int save_a, int save_b, int save_crc, int save_footer);
extern BOOL DEBUG_BACKUP_FlashSave(u32 src, void * dst, u32 len);
extern BOOL DEBUG_BACKUP_FlashLoad(u32 src, void * dst, u32 len);
#endif


#ifdef __cplusplus
}/* extern "C" */
#endif



//============================================================================================
/**
 * @file	msgdata.h
 * @brief	各種メッセージデータ取り扱い
 * @author	taya
 */
//============================================================================================
#ifndef __MSGDATA_H__
#define __MSGDATA_H__

#include "strbuf.h"

#ifdef __cplusplus
extern "C" {
#endif

/*==========================================================================================*/
/*
 *	■メッセージデータの構造
 *
 *    複数のメッセージデータファイルがまとめられた【アーカイブ】が一番大きな単位です。
 *    これは nnsarc で作成した通常のアーカイブファイルです。
 *    メッセージデータは必ずアーカイブして使います。
 *
 *
 *    【アーカイブ】の中にはいくつかの【メッセージデータ】がまとめられています。
 *    これは MessageEditor のデータをコンバートしたもので、ＧＦ独自仕様です。
 *
 *
 *    さらに【メッセージデータ】の中にはいくつかの【文字列】が存在します。
 *    つまりアプリケーションから必要な【文字列】を取得するためには、
 *    アーカイブＩＤ，メッセージデータＩＤ、文字列ＩＤの３つのキーが必要ということになります。
 *
 *
 *	■メッセージデータの取り扱い方法
 *
 *    メッセージデータの取り扱いインターフェイスは２種類あります。
 *
 *    Ａ．【メッセージデータ】全体をRAM上にロードしておき、そこから必要に応じて
 *        【文字列】をローカルのバッファにコピーして使う。
 *          不要になったら【メッセージデータ】を破棄する。
 *
 *    Ｂ．【文字列】が必要になるたびに、その【文字列】だけをRAM上にロードする。
 *         ローカルバッファにコピーしたら即座にロード領域は破棄する。
 *
 *    Ａ方式だと、沢山の【文字列】からなる【メッセージデータ】を取り扱う場合に、
 *    たかだか数10バイト程度の【文字列】が欲しいだけなのに、数千バイトの【メッセージデータ】を
 *    ロードすることになる可能性があります。
 *
 *   （例えば全ポケモン名が１つの【メッセージデータ】になっている場合、１文字２バイトなので
 *     大ざっぱに500体分とすると 500 * 5 * 2 で 5000 バイト。ローカライズ時にポケモン名が
 *     倍に伸びれば10000バイトです）
 *
 *    場合によっては、それほど贅沢にメモリを使えないケースというのもあるかもしれません。
 *    その場合はＢ方式を使ってください。
 *
 *    ただしこちらは文字列取得のたびにファイルリード、メモリ確保＆解放を行うので、
 *    多くの【文字列】を取得する場合には実行速度が犠牲になります。
 *
 *
 *	■メッセージデータマネージャについて
 *
 *    上記Ａ・Ｂのインターフェイス差を吸収し、アプリレベルでの修正を簡単にするための
 *    マネージャを用意しました。このマネージャを介してメッセージデータを取り扱うことで、
 *    Ａ方式からＢ方式に変えたい（あるいはその逆）という場合に、アプリケーションプロ
 *    グラム自体をほぼ変更せずに実現できます。詳細はマネージャ関数の説明をご覧ください。
 *
 *
 *==========================================================================================*/
//----------------------------------------------------
/**
 *  マネージャタイプ定義
 */
//----------------------------------------------------
typedef enum {
	///< Ａ方式。RAM上に必要なデータを保持し続けるので高速だがメモリを食う。
	MSGMAN_TYPE_NORMAL,	
	///< Ｂ方式。文字列取得ごとに必要最低限だけメモリ確保＆解放。省メモリだが遅い。
	MSGMAN_TYPE_DIRECT,	
}MSGMAN_TYPE;

//----------------------------------------------------
/**
 *  マネージャワーク構造体の型宣言
 */
//----------------------------------------------------
typedef struct _MSGDATA_MANAGER	MSGDATA_MANAGER;

//------------------------------------------------------------------
/**
 * メッセージデータマネージャ作成
 *
 * ※方式を変えたい場合、この関数の type 引数を変えるだけで良い。
 *
 *
 * @param   type		マネージャタイプ指定
 * @param   arcID		メッセージデータの含まれるアーカイブＩＤ
 * @param   datID		メッセージデータ本体のアーカイブ内ＩＤ
 * @param   heapID		メモリ確保用ヒープＩＤ
 *
 * @retval  MSGDATA_MANAGER*		作成したマネージャワークポインタ
 */
//------------------------------------------------------------------
extern MSGDATA_MANAGER*
	GFL_MSG_MANAGER_Create
		( MSGMAN_TYPE type, u32 arcID, u32 datID, HEAPID heapID );

//------------------------------------------------------------------
/**
 * メッセージデータマネージャの破棄
 *
 * @param   man		マネージャワークポインタ
 *
 */
//------------------------------------------------------------------
extern void
	GFL_MSG_MANAGER_Delete
		( MSGDATA_MANAGER* man );

//------------------------------------------------------------------
/**
 * メッセージデータマネージャを使って文字列を取得
 * （指定バッファにコピー）
 *
 * @param   man		マネージャワークポインタ
 * @param   strID	文字列ＩＤ
 * @param   dst		文字列コピー先バッファ
 *
 */
//------------------------------------------------------------------
extern void
	GFL_MSG_MANAGER_GetString
		( const MSGDATA_MANAGER* man, u32 strID, STRBUF* dst );

//------------------------------------------------------------------
/**
 * メッセージデータマネージャを使って文字列を取得
 *（内部でSTRBUFを作成して返す。作成されたSTRBUFの破棄は各自で行う）
 *
 * @param   man			マネージャワークポインタ
 * @param   strID		文字列ID
 *
 * @retval  STRBUF*		コピー先バッファポインタ
 *
 * 内部でSTRBUFがアロケートされるので
 * 使用後はGFL_STR_DeleteBufferなどで領域を開放すること
 */
//------------------------------------------------------------------
extern STRBUF*
	GFL_MSG_MANAGER_CreateString
		( const MSGDATA_MANAGER* man, u32 strID );

//------------------------------------------------------------------
/**
 * 格納されているメッセージ数を返す
 *
 * @param   man		マネージャワークポインタ
 *
 * @retval  u32		メッセージ数
 */
//------------------------------------------------------------------
extern u32
	GFL_MSG_MANAGER_GetMessageCount
		( const MSGDATA_MANAGER* man );


/*============================================================================================*/
/*                                                                                            */
/*  文字列タイプ切り替え                                                                      */
/*                                                                                            */
/*  同一の文字列IDを使って、実際に読み出される文字列を切り替えるための仕組み。                */
/*  日本語版の『ひらがな−漢字』切り替えとか、                                                */
/*  欧州版の『英・仏・独・伊・西』５ヶ国語切り替えとかに使ってもらうことを想定。              */
/*                                                                                            */
/*============================================================================================*/

//--------------------------------------------------------------------------------------
/**
 * 文字列タイプを設定する。
 * 以降、文字列取得関数を介して取得できる文字列が切り替わる。
 *
 * @param   kindID		文字列タイプ（デフォルトで0，以下連番）
 */
//--------------------------------------------------------------------------------------
extern void GFL_MSG_SetKindID( u32 kindID );

//--------------------------------------------------------------------------------------
/**
 * 設定されている文字列タイプを取得。
 *
 * @retval  u32		設定されている文字列タイプ
 */
//--------------------------------------------------------------------------------------
extern u32 GFL_MSG_GetKindID( void );


/*============================================================================================*/
/*                                                                                            */
/*                                                                                            */
/*  メッセージデータのコントロール                                                            */
/*                                                                                            */
/*                                                                                            */
/*============================================================================================*/
//------------------------------------------------------
/**
 *  メッセージデータヘッダ
 */
//------------------------------------------------------
typedef struct _MSGDATA_HEADER	MSGDATA_HEADER;

//------------------------------------------------------------------
/**
 * メッセージデータ郡をアーカイブからロードする
 *
 * @param   arcID		アーカイブファイルＩＤ
 * @param   datID		アーカイブファイル内のメッセージデータＩＤ
 * @param   heapID		ヒープＩＤ
 *
 * @retval  MSGDATA_HEADER*		メッセージデータポインタ
 */
//------------------------------------------------------------------
MSGDATA_HEADER*
	GFL_MSG_Create
		( u32 arcID, u32 datID, HEAPID heapID );

//------------------------------------------------------------------
/**
 * ロードしたメッセージデータ郡をアンロードする
 *
 * @param   msgdat		メッセージデータポインタ
 */
//------------------------------------------------------------------
void
	GFL_MSG_Delete
		( MSGDATA_HEADER* msgdat );

//------------------------------------------------------------------
/**
 * 文字列バッファ型オブジェクトに、指定文字列を取得
 *
 * @param   msgdat		メッセージデータポインタ
 * @param   strID		文字列ID
 * @param   dst			文字列バッファ型
 *
 */
//------------------------------------------------------------------
void
	GFL_MSG_GetString
		( const MSGDATA_HEADER* msgdat, u32 strID, STRBUF* dst );

//------------------------------------------------------------------
/**
 * 文字列バッファ型オブジェクトをメモリ確保し、指定文字列を取得
 *
 * @param   msgdat		メッセージデータポインタ
 * @param   strID		文字列ID
 * @param   heapID		メモリ確保用のヒープID
 *
 * @retval  文字列がコピーされた文字列バッファ型オブジェクトへのポインタ
 *
 * 内部でSTRBUFがアロケートされるので
 * 使用後はGFL_STR_DeleteBufferなどで領域を開放すること
 */
//------------------------------------------------------------------
STRBUF*
	GFL_MSG_CreateString
	( const MSGDATA_HEADER* msgdat, u32 strID, HEAPID heapID );

//------------------------------------------------------------------
/**
 * 指定文字列のみをロード＆指定バッファにコピー（アーカイブID指定）
 *
 * @param   arcID		アーカイブファイルＩＤ
 * @param   datID		アーカイブファイル内のメッセージデータＩＤ
 * @param   msgID		メッセージデータ内の文字列ＩＤ
 * @param   heapID		一時メモリ確保用のヒープＩＤ
 * @param   dst			文字列コピー先バッファ
 *
 */
//------------------------------------------------------------------
void
	GFL_MSG_GetStringDirect
		( u32 arcID, u32 datID, u32 strID, HEAPID heapID, STRBUF* dst );

//------------------------------------------------------------------
/**
 * 指定文字列のみをロード＆指定バッファにコピー（アーカイブハンドル使用）
 *
 * @param   arcHandle	アーカイブハンドル
 * @param   datID		アーカイブファイル内のメッセージデータＩＤ
 * @param   msgID		メッセージデータ内の文字列ＩＤ
 * @param   heapID		一時メモリ確保用のヒープＩＤ
 * @param   dst			文字列コピー先バッファ
 *
 */
//------------------------------------------------------------------
void
	GFL_MSG_GetStringDirectByHandle
		( ARCHANDLE* arcHandle, u32 datID, u32 strID, HEAPID heapID, STRBUF* dst );

//------------------------------------------------------------------
/**
 * 指定文字列のみをロード後、内部でアロケートしたメモリにコピーして返す
 *（アーカイブID指定）
 *
 * @param   arcID		アーカイブファイルＩＤ
 * @param   datID		アーカイブファイル内のメッセージデータＩＤ
 * @param   msgID		メッセージデータ内の文字列ＩＤ
 * @param   heapID		一時メモリ確保用のヒープＩＤ
 *
 * @retval  文字列がコピーされた文字列バッファ型オブジェクトへのポインタ
 *
 * 内部でSTRBUFがアロケートされるので
 * 使用後はGFL_STR_DeleteBufferなどで領域を開放すること
 */
//------------------------------------------------------------------
STRBUF*
	GFL_MSG_CreateStringDirect
		( u32 arcID, u32 datID, u32 strID, HEAPID heapID );

//------------------------------------------------------------------
/**
 * 指定文字列のみをロード後、内部でアロケートしたメモリにコピーして返す
 *（アーカイブハンドル使用）
 *
 * @param   arcHandle	アーカイブハンドル
 * @param   datID		アーカイブファイル内のメッセージデータＩＤ
 * @param   msgID		メッセージデータ内の文字列ＩＤ
 * @param   heapID		一時メモリ確保用のヒープＩＤ
 *
 * @retval  文字列がコピーされた文字列バッファ型オブジェクトへのポインタ
 *
 * 内部でSTRBUFがアロケートされるので
 * 使用後はGFL_STR_DeleteBufferなどで領域を開放すること
 */
//------------------------------------------------------------------
STRBUF*
	GFL_MSG_CreateStringDirectByHandle
		( ARCHANDLE* arcHandle, u32 datID, u32 strID, HEAPID heapID );

//------------------------------------------------------------------
/**
 * ロードしたメッセージデータを基に、格納されているメッセージの数を返す
 *
 * @param   msgdat		メッセージデータポインタ
 *
 * @retval  u32			メッセージ数
 */
//------------------------------------------------------------------
u32
	GFL_MSG_GetMessageCount
		( const MSGDATA_HEADER* msgdat );

//------------------------------------------------------------------
/**
 * アーカイブ＆データIDを基に、格納されているメッセージの数を返す
 *
 * @param   arcID		アーカイブID
 * @param   datID		データID
 *
 * @retval  u32			メッセージ数
 */
//------------------------------------------------------------------
u32
	GFL_MSG_GetMessageCountDirect
		( u32 arcID, u32 datID );


#ifdef __cplusplus
}/* extern "C" */
#endif



#endif

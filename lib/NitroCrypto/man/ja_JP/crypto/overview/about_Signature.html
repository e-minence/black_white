<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!--==========================================================================
  Copyright 2006 Nintendo.  All rights reserved.

  These coded instructions, statements, and computer programs contain
  proprietary information of Nintendo of America Inc. and/or Nintendo
  Company Ltd., and are protected by Federal copyright law.  They may
  not be disclosed to third parties or copied or duplicated in any form,
  in whole or in part, without the prior written consent of Nintendo.
 ==========================================================================-->
<HTML>
<HEAD>
	<META http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
	<META name="GENERATOR" content="IBM WebSphere Studio Homepage Builder Version 7.0.0.0 for Windows">
	<META http-equiv="Content-Style-Type" content="text/css">
	<TITLE>電子署名 (overview)</TITLE>
	<LINK rel="stylesheet" href="../../css/nitro.css" type="text/css">
</HEAD>
<BODY>
<H1 align="left">電子署名 (overview)</H1>
<H2>説明</H2>
<H3>電子署名とは</H3>
<P>
	電子署名とは、インターネットなどの信頼できない経路から送られてきたデータが、正当なものであることを証明するための機構です。
</P>
<BLOCKQUOTE><IMG src="image_Signature.gif" border="0"></BLOCKQUOTE>
<ul>
	<li>作業主体として署名する人（開発者）・検証する人（ユーザのDS）が関与します。</li>
	<li>データとしては、秘密鍵・公開鍵・送信データ・送信データに対する電子署名、が介在します。</li>
	<li>秘密鍵は署名する人だけが知っており、秘密にしています。</li>
	<li>公開鍵は、何らかの信頼できる手段（ゲームカードに焼きこまれている）により、検証する人が前もって入手しているものとします。</li>
	<li>送信データは任意のサイズのバイナリファイルです。</li>
</ul>
<ol>
	<li>まず、署名する人が秘密鍵を使用して、送信データから固定長の電子署名を作成します。<BR>
	（実際には、送信データのハッシュ値を取り、それに対して操作を行います。）</li>
	<li>その後、検証する人が、送信データとそのデータへの電子署名をインターネットなどを経由して受け取ります。</li>
	<li>検証する人は、あらかじめ入手していた公開鍵の情報だけを用いて、
	送信データとその署名から、データが正当なものであることを検証できます。</li>
</ol>
<P>
	電子署名という機構の特徴は以下のようになります。
</P>
<ul>
	<li>公開鍵さえ事前に知っていれば、外部との通信を行わずに、データとそれへの署名だけを用いて正当性を判定できる。</li>
	<li>公開鍵が明らかになっても、秘密鍵さえ漏洩しなければ、署名の偽造ができない。<BR>（すなわち、DS 側の ROM バイナリが万が一解析されたとしても、署名の偽造ができない。）</li>
</ul>

<H3>NITRO-SDK Crypto ライブラリが提供する電子署名機能</H3>
<P>
	<A href="../sign/CRYPTO_VerifySignature.html">CRYPTO_VerifySignature</A> 関数、<A href="../sign/CRYPTO_VerifySignatureWithHash.html">CRYPTO_VerifySignatureWithHash</A> 関数は
	最も基本的な電子署名の認証の仕組みを提供します。
	証明書という層がありませんので、証明書の有効期限の管理などの機能はありません。
	必要に応じて、アプリケーション側で機能を実装してください。
	なお、NITRO-SDK Crypto ライブラリでは電子署名の作成を行うことはできません。
</P>
<P>
	また、電子署名はデータの正当性の検証を行うだけの仕組みですので、データの暗号化は行いません。
	平文で送るのを避けたいという程度の要求であれば、<A href="../cipher/CRYPTO_RC4.html">CRYPTO_RC4*</A> 関数による暗号化機能を使用することが可能です。
	RC4 アルゴリズムに関しましては、<A href="about_RC4.html">RC4 アルゴリズム概要</A>を参照してください。
	もしくは、NITRO-SDK WiFi ライブラリを用いてサーバと安全に通信したい場合は SOC_EnableSsl 関数で有効化できる SSL 通信を用いてください。
</P>

<H3>署名データの形式</H3>
<P>
	CRYPTO_VerifySignature* 関数に渡す署名データは以下の条件を満たしていれば
	どのような方法で生成しても構いません。
</P>
<ul>
	<li>PKCS#1 に準拠している</li>
	<li>ハッシュアルゴリズムには SHA-1 を使用している</li>
	<li>公開鍵暗号のアルゴリズムには RSA を使用し、鍵長は 1024bit である</li>
	<li>使用している公開鍵の公開指数が 65537 である</li>
</ul>

<H3>署名データの作成例</H3>
<P>
	一例として、オープンソースの SSL ツールキットである OpenSSL で電子署名を作成する手順を以下に述べます。
</P>

<P><B>1. 署名用の RSA 鍵を生成する</B></P>
<P>
	OpenSSL がインストールされている環境のコマンドラインで、以下のコマンドを入力することで、
	鍵長 1024 bit の RSA 鍵ファイル privkey.pem を作成します。
</P>
<PRE><CODE> &gt; openssl genrsa -out privkey.pem 1024</CODE></PRE>
<P>
	万が一、privkey.pem が漏洩すると、誰もが署名できるようになってしまいます。
	秘密鍵の鍵ファイルは厳重に取り扱うようにしてください。
</P>
<P>
	鍵の作成時に暗号化方式を指定することで、privkey.pem にパスワードによる暗号化を行うことも可能です。
	以下の例では、新規に作成した privkey.pem を 3DES アルゴリズムによって暗号化します。
</P>
<PRE><CODE> &gt; openssl genrsa -des3 -out privkey.pem 1024</CODE></PRE>
<P>
	詳細は openssl のリファレンスを参照してください。
</P>

<P><B>2. RSA 鍵の内容を確認する</B></P>

<P>
	以下のコマンドで、privkey.pem の内容を確認することができます。
</P>

<PRE><CODE> &gt; openssl rsa -in privkey.pem -text -noout</CODE></PRE>

<P>
	この中には、署名を行うために必要な秘密情報が含まれていますが、
	後の検証のために必要な情報（公開鍵）は modulus と publicExponent の2つの数値です。<BR>
	以下はコマンドの出力から modulus と publicExponent を抜粋した例です。
</P>

<PRE><CODE>
modulus:
00:eb:95:be:33:19:73:64:f2:72:2c:87:c8:0a:f3:
1c:ba:e0:4c:e0:3e:1d:f6:e2:09:aa:70:f0:b3:b9:
0c:86:36:62:2d:12:13:86:fa:a5:3d:93:cb:5f:0b:
45:64:9b:7b:eb:b5:c6:f9:42:99:70:46:f3:14:6d:
8f:f9:b9:ec:38:30:a0:1c:28:0d:30:d9:86:1a:4d:
1b:f2:e9:05:1b:43:06:b2:c0:55:ed:c4:bb:8e:1a:
a5:ab:2b:54:e5:dc:8d:70:cf:af:91:94:c9:e9:8f:
7f:9f:29:28:be:e7:01:b0:20:d4:f2:71:58:93:db:
25:1c:26:bc:98:f3:a2:b3:47
publicExponent: 65537 (0x10001)
</CODE></PRE>

<P>
	CRYPTO_VerifySignature* 関数で扱う公開指数は 65537 で固定ですので、
	publicExponent が 65537 であることを確認してください。
</P>

<P>
	modulus の数値は、以下のコマンドで出力することも可能です。
</P>

<PRE><CODE> &gt; openssl rsa -in privkey.pem -modulus -noout</CODE></PRE>

<P>
	このコマンドでは以下のような文字列が出力されます。
</P>

<PRE><CODE> Modulus=EB95BE33197364F2722C87C80AF31CBAE04CE03E1DF6E209AA70F0B3B90C8636622D121386FAA53D93CB5F0B45649B7BEBB5C6F942997046F3146D8FF9B9EC3830A01C280D30D9861A4D1BF2E9051B4306B2C055EDC4BB8E1AA5AB2B54E5DC8D70CFAF9194C9E98F7F9F2928BEE701B020D4F2715893DB251C26BC98F3A2B347</CODE></PRE>

<P>
	この出力中の "Modulus=" の後に続く16進数を何らかの方法で
	C 言語の u8 の配列に変換して、CRYPTO_VerifySignature* 関数に mod_ptr として渡してください。
	なお、この出力例では Modulus が 127 バイトですが、このように 128 バイトより少ない場合は
	先頭（上位桁）の 0 が省略されていますので、
	全体が 128 バイトになるように先頭へ 0 を詰めた状態で mod_ptr に渡す必要があります。
</P>

<P><B>3. 電子署名を作成する</B></P>

<P>
	ここまで準備ができれば、あとは任意のデータを持って来て電子署名を作成するだけです。<BR>
	以下のコマンドで、秘密鍵 privkey.pem で hoge.txt を署名した hoge.sign という署名データが作成されます。
</P>

<PRE><CODE> &gt; openssl dgst -sha1 -sign privkey.pem -out hoge.sign hoge.txt</CODE></PRE>

<P>
	出来上がったファイルサイズが 128 バイトであることを確認してください。<BR>
	この 128 バイトのバイナリデータを DS に転送し、sign_ptr として CRYPTO_VerifySignature* 関数に渡します。<BR>
	なお、作成した署名データが正しい電子署名となっているかを PC 上で確認するには、以下のコマンドを実行します。
</P>

<PRE><CODE> &gt; openssl dgst -sha1 -prverify privkey.pem -signature hoge.sign hoge.txt</CODE></PRE>

<P><B>4. 電子署名を検証する</B></P>

<P>
	DS のプログラムに予め公開鍵データを埋め込んでおき、そこへ、通信などの何らかの手段でデータ本体とその電子署名データを送ります。
	CRYPTO_VerifySignature* 関数に対して、そのデータ本体とサイズ、電子署名データ(128バイト)と、
	埋め込まれた公開鍵データ(128バイトのmodulus)を与えることにより、電子署名を検証し、正当なものと認められれば関数は TRUE を返します。
</P>
<P>
<H2>参照</H2>
<P><CODE><A href="../list_crypto.html#sign">CRYPTO関数一覧</A><BR>
</CODE></P>
<H2>履歴</H2>
<P>
2006/03/07 初版</P>
</BODY>
</HTML>
